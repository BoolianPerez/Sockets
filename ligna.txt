import java.io.*;
import java.net.*;
import java.util.*;
import java.util.concurrent.*;

// Enum para definir los tópicos
enum Topic {
    TOPICA,
    TOPICB,
    TOPICC,
    TEATRO
}

// Clase para representar la información de un cliente
class ClientInfo {
    Socket socket;
    PrintWriter out;
    BufferedReader in;
    String name;
    Topic topic;

    public ClientInfo(Socket socket, PrintWriter out, BufferedReader in, String name, Topic topic) {
        this.socket = socket;
        this.out = out;
        this.in = in;
        this.name = name;
        this.topic = topic;
    }
}

public class BrokerServer {
    private static Map<Topic, List<ClientInfo>> topicSubscriptions = new ConcurrentHashMap<>();
    
    public static void main(String[] args) {
        int port = 12345;
        
        try (ServerSocket serverSocket = new ServerSocket(port)) {
            System.out.println("Broker Server is running on port " + port);
            
            while (true) {
                Socket clientSocket = serverSocket.accept();
                System.out.println("New client connected: " + clientSocket);
                
                // Crear un nuevo thread para manejar la conexión con el cliente
                Thread clientThread = new Thread(() -> handleClient(clientSocket));
                clientThread.start();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private static void handleClient(Socket clientSocket) {
        try {
            PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);
            BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));

            // Obtener el nombre y tópico del cliente
            out.println("Ingrese su nombre:");
            String name = in.readLine();
            
            out.println("Ingrese el número correspondiente al tópico al que desea suscribirse:");
            for (int i = 0; i < Topic.values().length; i++) {
                out.println(i + ". " + Topic.values()[i]);
            }
            int topicIndex = Integer.parseInt(in.readLine());
            Topic topic = Topic.values()[topicIndex];

            // Registrar la conexión en el tópico correspondiente
            ClientInfo clientInfo = new ClientInfo(clientSocket, out, in, name, topic);
            topicSubscriptions.computeIfAbsent(topic, k -> new ArrayList<>()).add(clientInfo);

            out.println("Bienvenido al tópico " + topic + ", " + name + "!");
            
            // Manejar la comunicación del cliente en el tópico
            String message;
            while ((message = in.readLine()) != null) {
                System.out.println("Received message from " + name + ": " + message);
                broadcastToTopic(topic, name + ": " + message);
                out.println("ACK"); // Enviar ACK al cliente
            }
            
            // Remover al cliente de la lista cuando se desconecta
            topicSubscriptions.get(topic).remove(clientInfo);
            System.out.println(name + " se desconectó.");
            clientSocket.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private static void broadcastToTopic(Topic topic, String message) {
        List<ClientInfo> subscribers = topicSubscriptions.get(topic);
        if (subscribers != null) {
            for (ClientInfo subscriber : subscribers) {
                try {
                    subscriber.out.println(message);
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
